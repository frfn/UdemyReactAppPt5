Setting up took almost 20-25 min since I had created app from npx create-react-app
 - Files all came from Udemy
 - Copied over the /src files and npm install
 - Created a GitHub so I can push changes and store them
 - Works as expected, first glance, 4 main files with Blog.js being the main file where all the components will go
 - NewPost.js is stateful while all our stateless (changed)
 - They are all class based components since we will be using lifecycle methods, we can use React Hooks here as well
 
1. Starting the AJAX / HTTP requests
     - We can use the built in XML / HTTP request methods but that will be cumbersome, we will use a third party library called Axios:
         - Axios
             - I can add to any React Application, it is JavaScript and used for XMLHTTPRequests
             - npm install axios --save
             - import axios 

         - Axios is Promise based
             - it will have something to report back to you
             - 3 states
                 - pending
                 - fulfilled
                 - rejected      
             - This means that the whole web page can load and does not need to wait for the process to finish, Axios is ASYNC + Promise based
             - Synchronous VS Asynchronous:
                 - Sync is one process at a given time
                 - Aysnc is multiple processes at a given time 

     - Storing the request from axios into a variable DOES NOT work
         - .get() is async, it does not finish immediately, it needs time to go to the server and collect data

         - to store it, use the state!
            - setState({
                posts: response.data
            })

     - Manipulate data!
         - Since response.data is an array, we can use methods on it and shorten it, map it, reduce, etc! 

         - In Blog.js, we have shortened it (using splice() method) and added an author property with the help of the spread operator ( ...post ) and .map()

         - Working with async methods should be thought of ahead of time, here I faced a problem where I am getting an error from FullPost.js
             - Network Loop

2. Getting familiar with data
     - axios.get('url').then( ..code ..)
         - this will return a JSON formatted data from the URL, in the example, the server we're pinging is RESTful. So it returns a JSON formatted data


     - axios.post('url', {obj})
         - we are sending an object to the server, and POSTing it

3. NewPost.js
     - I got ahead of myself and created something that would be nice if there were multiple forms. Using dynamic object naming notation, in setState, setting the values

     - I am getting over my head tbh, stay focused, and don't worry about 'remembering' all the things. No one knows everything. Stay motivated! Okay? :)

     - axios
         - I am using axios.post(url, obj, config) which takes in three arguments!
         - look at NewPost.js to see how it works


     - axios(url).then(response => { ..code.. })

     EXTRA:
         - added a 'Loading...' in the button component
         - was wondering how I can have text while the POST process happening,

4. deletePostHandler method
     - axios.delete(URL)
     - I took a look at how .delete() works, it is the URL that you need to delete the item
     - it is async/promise based SO it will return a response object

5. Blog.js
     - .catch() has been implemented and it is to catch if there are errors that occurs
     - created a property in state, error: false
     - set error to true in .catch() so that it indicates that there is an error that occured
     - changed the String for 'posts' so that it can display 'Oops, something went wrong...'
     - Done with an if statement, if ( !this.state.error ) { ..show posts.. } 

6. Interceptors â€“ so we can execute code gloablly (example, when a request from axios is sent)
     - I go to the most global file, index.js
     - index.js is what is mounted to the DOM
     - import axios from 'axios'
     - if I intercept, it will BLOCK the current request for Blog.js
         - to fix, return the requestConfig object!
     - The idea behind interceptors is that I can edit request configs
         - I can add headers, stuff like that
         - Powerful because we can add authorization headers as well
     - the second argument is for errors
     - you can add or remove by 
     axios.interceptors.request/response.use/eject(requestConfig/responseConfig => { .. code ..})
    
7. Setting default settings
     - Ease of use: instead of writing the URL every time, I can configure a setting
         - axios.defaults.baseURL = 'url'
     - Accessing headers and adding/modifying/deleting values in the property

8. Creating and Using Axios Instances
     - created a new file, axios.js
     - This is a copy of the axios object
     - commented out axios baseURL and common['Auth'] and put it in axios.js
         - Creating a new instance!
     - export default instance; -- its like exporting class or functional components
     - don't forget to change all of the classes that use Axios to use the newly created instance!
     - Note: I do not see the interceptors console log anymore (the request and response) because the setter was set up for the GLOBAL axios object

------------

9. ROUTING
    - Enables SPA properties
        - Multiple pages in a single page
        - One server, multiple pages, it is done by routing
    - Prep
        - Blog.js
            - created a header --> nav --> ul --> li, a href="/" | href="/new-posts"
            - created a CSS for the ul, li, a tags 
    - Setting Up
        - npm install --save react-router react-router-dom
            - MUST have both dependencies react-router AND react-router-dom
            - --save so it SAVES in the package.json 
        - router is NOT by Facebook
    - Start
        - comment out FullPost and NewPost
        - "/" is root path
        - "/new-post" is new post path, etc.
        - In Index or App, you MUST wrap part of the app that should render routes
            - Did in App.js
            - <BrowserRouter> enables routing!
                - Wraps <Blog /> so any component in Blog will get the logic for Routing
        - Created new folder in Blog folder, Posts
        - Moved NewPost and FullPost inside container/Blog because these are now DISTINCT pages because of routing
    - React Router vs React Router Dom
        - historically React Router is what you'd need, but React Router Dom is ultimately the dependency you need
    - Moved all the Post logic, state and code into Posts.js
        - Moved entirety of code from Blog.js to Posts.js, including the componentDidMount
        - removed the selectedPostId and error property in the state!
            - not needed because it was used in the Blog.js
    - Blog.js is just a skeleton now, a framework for the components to be in
        - Reformatted the Blog.js, modularized is all I did
    - Routing
        - Using the <Route /> tag to route to different 'pages' - also gives props to the component
            - RESERVED WORDS TO REMEMBER:
                - exact (for '/') - boolean value, by using this it will create an quasi-absolute path, if I do post/2, it will not load!
                - path="url_loc"
                - render={() => {jsx}} - Anonymous Function
                - component={component-name}, not the TAG (<Posts />) just 'Posts'

                ** use component keyword as a default. Only use render for small messages.

                <Route path='/' exact render={() => {jsx}}/>
                <Route path='/' exact component={Posts}
    - Reloading Issue?
        - We do not want to Reload because state will be refreshed and state will go away and restart.
        - How to stop that:
            - DO NOT use <a href>, use <Link> from 'react-router-dom' if using routing.
            - <Link /> reserved words
                - to='/'
                    - also accepts objects
                         to={{
                            pathname: 'loc',
                            hash: '#submit',
                            search: '?submit=true'
                            }}
    - Using 'component' inside the <Route component={Posts} /> is more recommended because more info is given
        - In action: render VS component, render reserved word does NOT give this.props information, no object is given!
        - IN URL:
            - new-post/2? ...
                - isExact in this.props changes to false as it is not EXACT path
    - Had to recap how the Post.js and Posts.js works
        - Collecting the post.id from .map() in Posts.js
            - method grabs the id when the <div> .. <article> has been pressed
                - IT WILL have its own data since the .map() iterates through all the items
    - import { withRouter } from 'react-router-dom'
        - adds router information to a component
        - used on Post.js to give more information for routes, it will give the props!
        - a HOC wrapper
            export default withRouter(post);
        - it will make the component 'Route Aware', it will GIVE access to router settings to the component!
    - Absolute Path VS Relative Path
        - Absolute:
            - always appended to root domain
            - example.com/new-post <-- main URL
            - if
                example.com/post/new-post <-- the URL will omit /post/
                and convert to: example.com/new-post
        - Relative:
            - this.props.match.url + '/new-post'
            - it appends the '/new-post' at the end of the previous URL
            - it becomes a relative path!

        - There is NO better way, pick any. 
    - Absolute vs Relative Paths (Article)
        You learned about <Link> , you learned about the to  property it uses.
        The path you can use in to can be either absolute or relative. 
        - Absolute Paths
            By default, if you just enter to="/some-path"  or to="some-path" , that's an absolute path. 
            Absolute path means that it's always appended right after your domain. Therefore, both syntaxes (with and without leading slash) lead to example.com/some-path .
        - Relative Paths
            Sometimes, you might want to create a relative path instead. This is especially useful, if your component is already loaded given a specific path (e.g. posts ) and you then want to append something to that existing path (so that you, for example, get /posts/new ).
            If you're on a component loaded via /posts , to="new"  would lead to example.com/new , NOT example.com/posts/new . 
            To change this behavior, you have to find out which path you're on and add the new fragment to that existing path. You can do that with the url  property of props.match :
            
            <Link to={props.match.url + '/new'}>  
            
            will lead to example.com/posts/new  when placing this link in a component loaded on /posts . If you'd use the same <Link>  in a component loaded via /all-posts , the link would point to /all-posts/new .
            
            There's no better or worse way of creating Link paths - choose the one you need. Sometimes, you want to ensure that you always load the same path, no matter on which path you already are => Use absolute paths in this scenario.
            Use relative paths if you want to navigate relative to your existing path.

    - Link VS NavLink component
        - activeClassName='active-Name'
            - instead of class="active", you can change the class name to however you like!

        - activeStyle={{
            color: 'blue',
            textDecoration: 'underline'
          }}
            - this gives the NavLink inline styling!

        - similar to Link but adds extra props to give styling to the link!
            from: import { Route, Link } from "react-router-dom";
            to:   import { Route, NavLink } from "react-router-dom";

            - We now have an '.active' class we can use!
            - In the CSS, adding Blog a.active will change the color
                - BUG: Both Links are highlighted... why? The '/' is treated as prefixes, since both '/' and '/new-posts' has '/', it treats it as a prefix
                - FIX: add 'exact' in the Link tag, it tells the Router, NO, it's not a prefix, it's the full path!
    
    